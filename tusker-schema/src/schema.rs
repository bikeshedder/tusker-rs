use itertools::Itertools;
use postgres_types::FromSql;
use serde::Deserialize;
use thiserror::Error;

use crate::sql::{quote_ident, StatementBuilder};

#[derive(Debug)]
pub struct Table {
    pub nspname: String,
    pub relname: String,
    pub relkind: Relkind,
    pub columns: Vec<Column>,
    pub viewdef: Option<String>,
}

impl Table {
    pub fn create(&self) -> String {
        let cols = self.columns.iter().map(|col| col.sql()).join(",\n    ");
        format!(
            "CREATE TABLE {}.{} (\n    {}\n);",
            quote_ident(&self.nspname),
            quote_ident(&self.relname),
            cols
        )
    }
}

#[derive(Debug, Deserialize)]
pub enum Relkind {
    #[serde(rename = "r")]
    OrdinaryTable,
    #[serde(rename = "i")]
    Index,
    #[serde(rename = "S")]
    Sequence,
    #[serde(rename = "t")]
    ToastTable,
    #[serde(rename = "v")]
    View,
    #[serde(rename = "m")]
    MaterializedView,
    #[serde(rename = "c")]
    CompositeType,
    #[serde(rename = "f")]
    ForeignTable,
    #[serde(rename = "p")]
    PartitionedTable,
    #[serde(rename = "I")]
    PartitionedIndex,
}

impl FromSql<'_> for Relkind {
    fn from_sql(
        _ty: &postgres_types::Type,
        raw: &[u8],
    ) -> Result<Self, Box<dyn std::error::Error + Sync + Send>> {
        Ok(match raw {
            b"r" => Self::OrdinaryTable,
            b"i" => Self::Index,
            b"S" => Self::Sequence,
            b"t" => Self::ToastTable,
            b"v" => Self::View,
            b"m" => Self::MaterializedView,
            b"c" => Self::CompositeType,
            b"p" => Self::PartitionedTable,
            b"I" => Self::PartitionedIndex,
            x => Err(UnsupportedRelkind(x.to_owned()))?,
        })
    }
    fn accepts(ty: &postgres_types::Type) -> bool {
        *ty == postgres_types::Type::CHAR
    }
}

#[derive(Error, Debug)]
#[error("Unsupported relkind value")]
struct UnsupportedRelkind(Vec<u8>);

#[derive(Debug, Deserialize)]
pub struct Column {
    pub num: u16,
    pub name: String,
    pub r#type: String,
    pub notnull: bool,
    pub identity: Identity,
    pub generated: Generated,
    pub default: Option<String>,
}

impl Column {
    pub fn sql(&self) -> String {
        // https://www.postgresql.org/docs/16/sql-createtable.html
        let mut s = StatementBuilder::new();
        s.ident(&self.name);
        s.part(&self.r#type); // FIXME quoting needed for user types/tables?
        if self.notnull {
            s.part("NOT NULL");
        }
        match self.generated {
            Generated::No => {}
            Generated::Stored => {
                s.part("GENERATED ALWAYS AS");
                s.part(self.default.as_ref().unwrap());
                s.part("STORED");
            }
        }
        match self.identity {
            Identity::No => {}
            Identity::Default => {
                s.part("GENERATED BY DEFAULT AS IDENTITY");
                if let Some(d) = &self.default {
                    s.part(format!("({})", d));
                }
            }
            Identity::Always => {
                s.part("GENERATED ALWAYS AS IDENTITY");
                if let Some(d) = &self.default {
                    s.part(format!("({})", d));
                }
            }
        }
        s.to_string()
    }
}

#[derive(Debug, Deserialize)]
pub enum Generated {
    #[serde(rename = "")]
    No,
    #[serde(rename = "s")]
    Stored,
}

#[derive(Debug, Deserialize)]
pub enum Identity {
    #[serde(rename = "")]
    No,
    #[serde(rename = "a")]
    Always,
    #[serde(rename = "d")]
    Default,
}
